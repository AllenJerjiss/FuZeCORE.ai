#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! ```

use std::env;
use std::fs;
use std::io::{self, Write};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 4 {
        eprintln!("Usage: {} <rca_analysis_file> <debugging_output_file> <output_fix_plan_file>", args[0]);
        std::process::exit(1);
    }
    
    let rca_file = &args[1];
    let debug_file = &args[2];
    let output_file = &args[3];
    
    // Read all context files
    let rca_content = fs::read_to_string(rca_file)
        .map_err(|e| format!("Failed to read RCA analysis file '{}': {}", rca_file, e))?;
    
    let debug_content = fs::read_to_string(debug_file)
        .map_err(|e| format!("Failed to read debugging output file '{}': {}", debug_file, e))?;
    
    // Generate surgical fix plan based on RCA and debugging analysis
    let fix_plan = generate_surgical_fix_plan(&rca_content, &debug_content)?;
    
    // Write fix plan to file
    fs::write(output_file, &fix_plan)
        .map_err(|e| format!("Failed to write fix plan to '{}': {}", output_file, e))?;
    
    // Make the output file executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = fs::metadata(output_file)?;
        let mut permissions = metadata.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(output_file, permissions)?;
    }
    
    // Print the fix plan to console
    print!("{}", fix_plan);
    
    Ok(())
}

fn generate_surgical_fix_plan(rca_content: &str, debug_content: &str) -> Result<String, Box<dyn std::error::Error>> {
    let mut plan = String::new();
    
    plan.push_str("#!/bin/bash\n");
    plan.push_str("# Auto-generated surgical fix plan based on RCA analysis and debugging evidence\n");
    plan.push_str("# Generated by fix-plan.rs\n\n");
    
    plan.push_str("echo \"=== SURGICAL FIX EXECUTION PLAN ===\"\n");
    plan.push_str("echo \"Based on RCA analysis and debugging forensics\"\n");
    plan.push_str("echo\n\n");
    
    // Analyze the debugging output for specific issues
    let issues = analyze_system_issues(&debug_content)?;
    
    // Generate fixes for each identified issue
    for (i, issue) in issues.iter().enumerate() {
        plan.push_str(&format!("echo \"# FIX {}: {}\"\n", i + 1, issue.description));
        plan.push_str(&generate_fix_section(issue)?);
        plan.push_str("\n");
    }
    
    plan.push_str("echo \"=== END OF SURGICAL FIX PLAN ===\"\n");
    plan.push_str("echo \"# This plan was generated but NOT executed\"\n");
    plan.push_str("echo \"# Review each section before manual execution\"\n");
    
    Ok(plan)
}

#[derive(Debug)]
struct SystemIssue {
    description: String,
    file_path: String,
    fix_type: FixType,
    evidence: String,
}

#[derive(Debug)]
enum FixType {
    MissingFile,
    ConfigurationError,
    RegexPattern,
    PathMismatch,
    ServiceConfig,
    PathResolution,  // New type for path resolution issues
}

fn analyze_system_issues(debug_content: &str) -> Result<Vec<SystemIssue>, Box<dyn std::error::Error>> {
    let mut issues = Vec::new();
    
    // First, check if there's a re-do.txt file with a specific problem statement
    if let Ok(redo_content) = fs::read_to_string("re-do.txt") {
        eprintln!("Found re-do.txt, analyzing specific issues...");
        return analyze_redo_issues(&redo_content, debug_content);
    }
    
    // Fallback: Analyze from debug content and RCA for initial runs
    eprintln!("No re-do.txt found, analyzing from debug content...");
    
    // Only add issues if there's actual evidence they exist and aren't already fixed
    
    // Check for missing nuke-all.sh only if we have evidence it's missing
    if debug_content.contains("nuke-all.sh") && debug_content.contains("MISSING") {
        issues.push(SystemIssue {
            description: "Missing nuke-all.sh nuclear cleanup wrapper".to_string(),
            file_path: "/home/fuze/GitHub/FuZeCORE.ai/factory/LLM/refinery/stack/ollama/nuke-all.sh".to_string(),
            fix_type: FixType::MissingFile,
            evidence: "FAILURE: ✗ nuke-all.sh -> NEW FILE - nuclear cleanup wrapper (MISSING!)".to_string(),
        });
    }
    
    // Check for service-cleanup.sh issues only if we have evidence
    if debug_content.contains("service-cleanup.sh") && debug_content.contains("MODELDIR") {
        issues.push(SystemIssue {
            description: "service-cleanup.sh missing MODELDIR path configuration".to_string(),
            file_path: "/home/fuze/GitHub/FuZeCORE.ai/factory/LLM/refinery/stack/ollama/service-cleanup.sh".to_string(),
            fix_type: FixType::PathMismatch,
            evidence: "FAILURE: ✗ service-cleanup.sh -> MODELDIR path (MISSING!)".to_string(),
        });
    }
    
    // Check for cleanup-variants.sh regex issues only if we have evidence of malformed names
    if debug_content.contains("LLM-FuZe-LLM-FuZe-") || debug_content.contains("unknown pattern") {
        issues.push(SystemIssue {
            description: "cleanup-variants.sh missing MATCH_RE regex pattern for malformed names".to_string(),
            file_path: "/home/fuze/GitHub/FuZeCORE.ai/factory/LLM/refinery/stack/ollama/cleanup-variants.sh".to_string(),
            fix_type: FixType::RegexPattern,
            evidence: "UNKNOWN: ? unknown pattern: LLM-FuZe-LLM-FuZe-gpt-oss-20b-gpu0-ng80-latest-gpu0-ng80".to_string(),
        });
    }
    
    Ok(issues)
}

fn generate_fix_section(issue: &SystemIssue) -> Result<String, Box<dyn std::error::Error>> {
    let mut section = String::new();
    
    match issue.fix_type {
        FixType::MissingFile => {
            if issue.file_path.contains("nuke-all.sh") {
                section.push_str(&format!("cat > {} << 'EOF'\n", issue.file_path));
                section.push_str("#!/bin/bash\n");
                section.push_str("# Nuclear cleanup wrapper for ollama - removes ALL models and data\n");
                section.push_str("# WARNING: This script will destroy all ollama data\n\n");
                section.push_str("set -euo pipefail\n\n");
                section.push_str("echo \"WARNING: This will delete ALL ollama models and data\"\n");
                section.push_str("echo \"Current ollama data size: $(du -sh /FuZe/ollama 2>/dev/null || echo 'N/A')\"\n");
                section.push_str("echo \"Press Ctrl+C to abort, or wait 10 seconds to continue...\"\n");
                section.push_str("sleep 10\n\n");
                section.push_str("# Stop all ollama services\n");
                section.push_str("systemctl stop ollama.service ollama-test-a.service ollama-test-b.service 2>/dev/null || true\n\n");
                section.push_str("# Kill any remaining ollama processes\n");
                section.push_str("pkill -f ollama || true\n");
                section.push_str("sleep 2\n\n");
                section.push_str("# Remove all model data\n");
                section.push_str("rm -rf /FuZe/ollama/manifests/*\n");
                section.push_str("rm -rf /FuZe/ollama/blobs/*\n");
                section.push_str("rm -rf /FuZe/baked/ollama/*\n\n");
                section.push_str("echo \"Nuclear cleanup completed - all ollama data removed\"\n");
                section.push_str("EOF\n");
                section.push_str(&format!("chmod +x {}\n", issue.file_path));
            }
        },
        
        FixType::PathMismatch => {
            if issue.file_path.contains("service-cleanup.sh") {
                section.push_str(&format!("# Fix MODELDIR path in {}\n", issue.file_path));
                section.push_str(&format!("sed -i 's|MODELDIR=.*|MODELDIR=\"/FuZe/ollama\"|g' {}\n", issue.file_path));
                section.push_str(&format!("sed -i 's|/FuZe/models/ollama|/FuZe/ollama|g' {}\n", issue.file_path));
            } else if issue.file_path.contains("store-cleanup.sh") {
                section.push_str(&format!("# Fix CANON/ALT_DEFAULT paths in {}\n", issue.file_path));
                section.push_str(&format!("sed -i 's|CANON_DEFAULT=.*|CANON_DEFAULT=\"/FuZe/ollama\"|g' {}\n", issue.file_path));
                section.push_str(&format!("sed -i 's|ALT_DEFAULT=.*|ALT_DEFAULT=\"/FuZe/baked/ollama\"|g' {}\n", issue.file_path));
                section.push_str(&format!("sed -i 's|/FuZe/models/ollama|/FuZe/ollama|g' {}\n", issue.file_path));
            }
        },
        
        FixType::RegexPattern => {
            if issue.file_path.contains("cleanup-variants.sh") {
                section.push_str(&format!("# Fix regex patterns in {} to handle malformed model names\n", issue.file_path));
                section.push_str("cat >> /tmp/cleanup-variants-fix.patch << 'EOF'\n");
                section.push_str("# Enhanced regex patterns to handle malformed model names\n");
                section.push_str("# Original pattern: MATCH_RE=\"^LLM-FuZe-.*-(gpu[0-9]+|[0-9]+ti|[0-9]+)-ng[0-9]+:latest$\"\n");
                section.push_str("# Enhanced pattern to catch malformed names:\n");
                section.push_str("MATCH_RE=\"^LLM-FuZe-.*\"\n");
                section.push_str("MALFORMED_RE=\"^LLM-FuZe-LLM-FuZe-.*\"\n");
                section.push_str("GPU_PATTERN_RE=\"(gpu[0-9]+|[0-9]+ti|[0-9]+|3090ti|5090)\"\n");
                section.push_str("EOF\n");
                section.push_str(&format!("# Apply enhanced regex to {}\n", issue.file_path));
                section.push_str(&format!("sed -i '/MATCH_RE=/c\\MATCH_RE=\"^LLM-FuZe-.*\"' {}\n", issue.file_path));
                section.push_str(&format!("sed -i '/MATCH_RE=/a\\MALFORMED_RE=\"^LLM-FuZe-LLM-FuZe-.*\"' {}\n", issue.file_path));
                section.push_str(&format!("sed -i '/MALFORMED_RE=/a\\GPU_PATTERN_RE=\"(gpu[0-9]+|[0-9]+ti|[0-9]+|3090ti|5090)\"' {}\n", issue.file_path));
            }
        },
        
        FixType::ConfigurationError => {
            section.push_str(&format!("# Configuration error fix for {}\n", issue.file_path));
            section.push_str("# Manual intervention required\n");
        },
        
        FixType::ServiceConfig => {
            section.push_str("# Service configuration fixes\n");
            section.push_str("systemctl daemon-reload\n");
        },
    }
    
    section.push_str("echo \"Fixed: ");
    section.push_str(&issue.description);
    section.push_str("\"\n");
    
    Ok(section)
}